import os
import sys
import re
import time
import subprocess
import numpy as np
from textwrap import dedent


class DGLM3DBase:
    def __init__(self, dglm_dir, work_dir, N, Nvar, tmax, dglm_param):
        '''
        Base class for a 3D DGLM simulation
        
        dglm_dir(str): DGLM directory path (eg, '/home/parl/lab/DGLM/0.3.2')
        work_dir(str): WORK directory path
        
        N   (int) : polynomial order
        Nvar(int) : number of variables (eg. advection=1, euler=5)
        tmax(int) : simulation time        
        
        dglm_param(dict):
            'CFL'      : Courant-Friedrichs-Lewy Number (default=0.8)
            'gamma'    : model parameter (default=1.4)
            'tau_scale': model parameter (default=1.2)
            'interpN'  : high-order polynomial order for interpolation (default=2)
            'dtype'    : floating-point data type (default: 'f8')
        '''
        
        self.dglm_dir = os.path.abspath(dglm_dir)
        self.work_dir = os.path.abspath(work_dir)
        
        self.N     = N     # polynomial order
        self.Nvar  = Nvar  # number of governing variables
        self.tmax  = tmax  # end time
        
        self.param = {'CFL':0.8, 'gamma':1.4, 'tau_scale':1.2, 'interpN':2, 'dtype':'f8'}
        self.param.update(dglm_param)
        
        # create DG component objects
        sys.path.append(dglm_dir + '/dim3/src/python')
        from tetra import TetraRef
        from operator_3d_ref import Operator3DRef
        from operator_3d_face import Operator3DFace

        self.tet = TetraRef(N, self.param['interpN'])
        self.op_ref = Operator3DRef(self.tet)
        self.op_face = Operator3DFace(self.op_ref)
        
        self.Np    = self.tet.Np
        self.Nfp   = self.tet.Nfp
        self.Nface = self.tet.Nface        
    
    
    def init_mesh(self):
        '''
        create a mesh object
        '''
        pass
        
    
    def make_work_dir(self):
        '''
        make the work directory and sub-directories
        '''
        self.datain_dir = os.path.join(self.work_dir, 'datain')
        self.dataout_dir = os.path.join(self.work_dir, 'dataout')
        
        os.makedirs(self.work_dir, exist_ok=True)
        os.makedirs(self.datain_dir, exist_ok=True)
        os.makedirs(self.dataout_dir, exist_ok=True)
        
                    
    def save_to_binaries(self, extra_arr_dict={}, matrix_order='c', verbose=1):
        '''
        Save DG operation matrices and mesh information generated by preprocessing
        to binary files for use in C/CUDA code
        
        [input]
        extra_arr_dict: specify extra arrays in addition to the default arrays
        matrix_order  : 'c' for CPU or 'f' for cuBLAS
        verbose       : stdout level (0:no stdout, 1:minimal, 2:detail)
        '''        
        
        arr_dict = {}
        
        #
        # dimension array (cannot use #define in header)
        #
        dim_list = [self.mesh.Nelem]  # Other variables will be added in partition version
        arr_dict['dim'] = np.array(dim_list, 'i4')
        
        #
        # index array
        #
        arr_dict['EtoB'] = self.mesh.EtoB       # shape (Nelem,Nface)
        arr_dict['vmapP'] = self.mesh.vmapP     # shape (Nelem,Nface,Nfp)
        arr_dict['vmapF'] = self.mesh.vmapF     # shape (Nelem,Nface)
        arr_dict['Fmask'] = self.op_face.Fmask  # shape (Nface,Nfp)
        
        #
        # data array
        #
        arr_dict['WDr']  = self.op_ref.WDr    # shape (Np,Np)
        arr_dict['WDs']  = self.op_ref.WDs    # shape (Np,Np)
        arr_dict['WDt']  = self.op_ref.WDt    # shape (Np,Np)
        arr_dict['LIFT'] = self.op_face.LIFT  # shape (Np,Nface*Nfp)
        
        arr_dict['Fscale'] = self.mesh.Fscale  # shape (Nelem,Nface)
        arr_dict['rx'] = self.mesh.rx  # shape (Nelem,)
        arr_dict['ry'] = self.mesh.ry  # shape (Nelem,)
        arr_dict['rz'] = self.mesh.rz  # shape (Nelem,)
        arr_dict['sx'] = self.mesh.sx  # shape (Nelem,)
        arr_dict['sy'] = self.mesh.sy  # shape (Nelem,)
        arr_dict['sz'] = self.mesh.sz  # shape (Nelem,)
        arr_dict['tx'] = self.mesh.tx  # shape (Nelem,)
        arr_dict['ty'] = self.mesh.ty  # shape (Nelem,)
        arr_dict['tz'] = self.mesh.tz  # shape (Nelem,)
        arr_dict['nx'] = self.mesh.NX  # shape (Nelem,Nface)
        arr_dict['ny'] = self.mesh.NY  # shape (Nelem,Nface)
        arr_dict['nz'] = self.mesh.NZ  # shape (Nelem,Nface)
        arr_dict['px'] = self.mesh.PX  # shape (Nelem,Np)
        arr_dict['py'] = self.mesh.PY  # shape (Nelem,Np)
        arr_dict['pz'] = self.mesh.PZ  # shape (Nelem,Np)
        
        #
        # extra array
        #
        arr_dict.update(extra_arr_dict)
        
        #
        # write flatten array to files
        #
        if verbose >= 1: 
            dpath = self.datain_dir.replace(self.work_dir, 'WORK_DIR')
            print(f"Save DG arrays to *.bin files in {dpath}/")
            
        for name, arr in arr_dict.items():
            if arr.dtype in [np.float32, np.float64]:
                arr = arr.astype(self.param['dtype'])
                
            fpath = os.path.join(self.datain_dir, f'{name}.bin')
            with open(fpath, 'wb') as f:
                if name in ['WDr', 'WDs', 'WDt', 'LIFT']:
                    arr.ravel(matrix_order).tofile(f)
                else:
                    arr.ravel().tofile(f)
                
            if verbose >= 2: print(f"  {os.path.basename(fpath)}")
    

    def save_to_header(self, filename_list=[], extra_str_dict={}, extra_num_dict={}, verbose=1):
        str_dict = {
            'REAL': {'f8':'double', 'f4':'float'}[self.param['dtype']],
            'DATAIN': f'"{self.datain_dir}/"',
            'DATAOUT': f'"{self.dataout_dir}/"',
        }
        str_dict.update(extra_str_dict)
        
        num_dict = {
            'PI'    : 3.14159265358979323846,
            'TDIGIT': 7,
            'N'     : self.tet.N,
            'NP'    : self.tet.Np,
            'NFP'   : self.tet.Nfp,
            'NFACE' : self.tet.Nface,
            'NROT'  : self.tet.Nrot,
            'NVAR'  : self.Nvar,
            'TMAX'  : self.tmax,
            'CFL'   : self.param['CFL'],
            'GAMMA' : self.param['gamma'],
            'TAU_SCALE': self.param['tau_scale'],
        }
        num_dict.update(extra_num_dict)
        
        if filename_list == []:
            filename_list = ['io.cpp', 'class.cpp', 'dglm.cpp']
        
        #
        # make a header file
        #
        header  = "#ifndef COMMON_H\n"
        header += "#define COMMON_H\n"
        
        header += "\n"
        for k, v in str_dict.items():
            header += f"#define {k.ljust(7)} {v}\n"
            
        header += "\n"
        for k, v in num_dict.items():
            header += f"#define {k.ljust(6)} {v}\n"
            
        header += "\n"
        header += '#include "io.cpp"\n'
        for filename in filename_list:
            header += f'#include "{filename}"\n'
        
        header += "\n"
        header += "#endif"        
        
        fpath = os.path.join(self.work_dir, 'common.h')
        with open(fpath, 'w') as f:
            f.write(header)
        
        if verbose >= 1: print(f"Save common.h files in WORK_DIR/")
        
        
    def link_codes(self, filename_list, verbose=1):
        if verbose >= 1: print(f"Link C/CUDA codes in WORK_DIR/")
        
        def symlink(src, dst):
            try:
                if verbose >= 2: print(f"  {os.path.basename(dst)}") 
                os.symlink(src, dst)
            except FileExistsError:
                os.remove(dst)
                os.symlink(src, dst)
        
        # io file
        src_fpath = os.path.join(self.dglm_dir, 'utils', 'src', 'cpp', 'io.cpp')
        dst_fpath = os.path.join(self.work_dir, 'io.cpp')
        symlink(src_fpath, dst_fpath)
        
        # dglm files
        src_cpp_dir = os.path.join(self.dglm_dir, 'dim3', 'src', 'cpp')
        src_cuda_dir = os.path.join(self.dglm_dir, 'dim3', 'src', 'cuda')
                           
        for fname in filename_list:
            if fname.endswith('.cpp'):
                src_fpath = os.path.join(src_cpp_dir, fname)
            elif fname.endswith('.cu'):
                src_fpath = os.path.join(src_cuda_dir, fname)
                
            dst_fpath = os.path.join(self.work_dir, fname)
            symlink(src_fpath, dst_fpath)
        

    def check_mem_size(self, class_filename, verbose=1):
        n_dict = {'nelem':self.Nelem, 'N':self.N, 'NP':self.Np, 'NFACE':self.Nface, 'NFP':self.Nfp, 'NVAR':self.Nvar}
        if class_filename.endswith('.cu'):
            n_dict.update({'pNP':self.pNP, 'pNFF':self.pNFF})
        if '_mpi_' in class_filename:
            n_dict.update({'comm_size':self.comm_size, 'buf_size':self.buf_size})
            
        real = {'f8':'double', 'f4':'float'}[self.param['dtype']]
        
        sys.path.append(os.path.join(self.dglm_dir, 'utils', 'src', 'python'))
        from mem_size import print_mem_cpp, print_mem_cuda
        
        class_file = os.path.join(self.work_dir, class_filename)
        with open(class_file, 'r') as f:
            if class_filename.endswith('.cpp'):
                total_bytes = print_mem_cpp(n_dict, real, f.read(), verbose)                
            elif class_filename.endswith('.cu'):
                total_bytes = print_mem_cuda(n_dict, real, f.read(), verbose)
                
        return total_bytes
            
    
    def build(self, compile_cmd, filename_list, verbose=1):
        for filename in filename_list:
            src = os.path.join(self.work_dir, filename)
            
            if filename.endswith('.cpp'):  
                dst = src.rstrip('.cpp')
            elif filename.endswith('.cu'):
                dst = src.rstrip('.cu')
            
            cmd = compile_cmd + f" {src} -o {dst}"

            if verbose >= 1: print(cmd)
            result = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

            if result.returncode != 0:
                if result.stderr:
                    raise RuntimeError(f"Error occurred: {result.stderr}")
                else:
                    raise RuntimeError("Command failed with non-zero exit code")
            else:
                if verbose >= 2: print(result.stdout)
                
    
    def run(self, filename, omp_threads=None, verbose=1):
        fpath = os.path.join(self.work_dir, filename)
        
        if '_mpi_' in filename:
            if omp_threads == None:
                #cmd = f"mpiexec -n {self.mpisize} {fpath}"
                #cmd = f"mpiexec -n {self.mpisize} --allow-run-as-root {fpath}"
                cmd = f"mpiexec -n {self.mpisize} --mca coll ^hcoll --allow-run-as-root {fpath}"
            else:
                #cmd = f"export OMP_NUM_THREADS={omp_threads} && mpiexec -n {self.mpisize} {fpath}"
                cmd = f"export OMP_NUM_THREADS={omp_threads} && mpiexec -n {self.mpisize} --mca coll ^hcoll --allow-run-as-root {fpath}"
        else:
            cmd = fpath
            
        if verbose >= 1: print(cmd)
        
        start_time = time.perf_counter()
        result = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        end_time = time.perf_counter()
        elapsed_time = end_time - start_time
        
        if result.returncode != 0:
            if result.stderr:
                raise RuntimeError(f"Error occurred: {result.stderr}")
            else:
                raise RuntimeError("Command failed with non-zero exit code")
        else:
            if verbose >= 2: print(result.stdout)
            
        #
        # execution stdout example
        # tstep=30, dt=0.00182172, t=0.05465
        #
        matches1 = re.findall(r"tstep=(\d+)", result.stdout)  # [str, str, ...]
        matches2 = re.findall(r"dt=([0-9.]+)", result.stdout)
        if not matches1: return -1, -1, -1
    
        last_tstep = int(matches1[-1])
        avg_dt = np.array(matches2, 'f8').mean()
            
        if verbose >=1: print(f"tstep={last_tstep}, dt={avg_dt:.5f}, elapsed_time={elapsed_time:.5f}")

        return last_tstep, avg_dt, elapsed_time
    
    
    def l2_error(self, ref_sol, numeric_sol, apply_sqrt=True):
        '''
        Calculate L2 error between reference solution and numerical solution
        Two solutions should have the same shape.
        Note: They use the high interpolation order ('interpN'=2)
        '''
        
        Nelem, Np = self.Nelem, self.Np
        high_Np = self.tet.high_Np
        
        Eint = np.zeros(Nelem)

        for ei in range(Nelem):
            high_sl = slice(ei*high_Np, (ei+1)*high_Np)
            sl = slice(ei*Np, (ei+1)*Np)
            
            u_ref = ref_sol[high_sl]
            u_num = self.op_ref.interpM@numeric_sol[sl]  # interpolation to high order
    
            E = u_ref[:] - u_num[:]
            M = self.op_ref.high_M            
            J = self.mesh.J[ei]
            Eint[ei] = J*(E@M@E)
    
        if apply_sqrt:
            return np.sqrt(np.sum(Eint))
        else:
            return np.sum(Eint)
        
        

#==============================================================================
class DGLM3DSingleCPU(DGLM3DBase):
    def init_mesh(self, mesh_info, verbose=1):
        '''        
        mesh_info(dict):
            {'type':'gmsh', 'file':msh_file_fpath }
            {'type':'uniform', 'param':[nx, ny, nz, x1, x2, y1, y2, z1, z2, {'x':'pbc', 'y':'pbc', 'z':'pbc'}]}
        '''
        
        from mesh_3d import Mesh3D
        
        if mesh_info["type"] == "gmsh":            
            from gmsh_3d_single import Gmsh3DSingle
            mesh_elem = Gmsh3DSingle(mesh_info["file"])  # *.msh file generated by Gmsh
            if verbose >= 1: print(f"Init Gmsh file: {mesh_info['file']}")
        
        elif mesh_info["type"] == "uniform":
            from uniform_3d_single import Uniform3DSingle
            mesh_elem = Uniform3DSingle(*mesh_info["param"])
            if verbose >= 1: print(f"Init uniform mesh: {mesh_info['param']}")
            
        self.mesh = Mesh3D(self.op_face, mesh_elem)
        self.Nelem = self.mesh.Nelem
    
    
    def build(self, filename_list, use_sanitize=False, verbose=1):
        #cmd = f"g++ -std=c++11"                                   # serial
        #cmd = f"g++ -O3 -std=c++11 -fno-tree-vectorize"           # opt3, no vectorize
        #cmd = f"g++ -O3 -std=c++11 -march=native -fopt-info-vec"  # opt3, vectorize
        
        if use_sanitize:                
            cmd = f"g++ -O3 -std=c++11 -fopenmp -march=native -fsanitize=address,undefined"
        else:
            cmd = f"g++ -O3 -std=c++11 -fopenmp -march=native"     # opt3, vectorize, openmp
                
        super().build(cmd, filename_list, verbose)

        
        
#==============================================================================
class DGLM3DSingleGPU(DGLM3DSingleCPU):
    def __init__(self, dglm_dir, work_dir, N, Nvar, tmax, dglm_param, devid=0):
        self.devid = devid
        
        super().__init__(dglm_dir, work_dir, N, Nvar, tmax, dglm_param)
        
        # padded dimensions
        self.pNP  = ((self.Np - 1)//32 + 1)*32
        self.pNFF = ((self.Nface*self.Nfp - 1)//32 + 1)*32
        
        
    def save_to_header(self, filename_list=[], extra_str_dict={}, extra_num_dict={}, verbose=1):
        def find_tpb_maxv(NFF):
            # TPB (Threads Per Block) for calc_maxv() kernel
            m = 2
            min_diff = 1024
            opt_tpb  = -1

            while True:
                tpb = NFF*m
                if (tpb > 1024): break

                for ref_tpb in [256, 512, 1024]:
                    diff = abs(tpb - ref_tpb)
                    if diff < min_diff:
                        min_diff = diff
                        opt_tpb = tpb
                m += 2
            return opt_tpb        
        
        fmax = {'f8':'fmax', 'f4':'fmaxf'}[self.param['dtype']]
        banksize = {'f8':'cudaSharedMemBankSizeEightByte',
                    'f4':'cudaSharedMemBankSizeFourByte'}[self.param['dtype']]
        cu_amax = {'f8':'cublasIdamax', 'f4':'cublasIsamax'}[self.param['dtype']]
        cu_gemm = {'f8':'cublasDgemm', 'f4':'cublasSgemm'}[self.param['dtype']]
        cu_gemm_batch = {'f8':'cublasDgemmBatched', 'f4':'cublasSgemmBatched'}[self.param['dtype']]

        dtype = self.param['dtype']
        str_dict = {}
        str_dict['FMAX'] = {'f8':'fmax', 'f4':'fmaxf'}[dtype]
        str_dict['cudaSharedMemBankSizeTByte'] = \
                {'f8':'cudaSharedMemBankSizeEightByte',
                 'f4':'cudaSharedMemBankSizeFourByte'}[dtype]
        str_dict['cublasITAMAX'] = {'f8':'cublasIdamax', 'f4':'cublasIsamax'}[dtype]
        str_dict['cublasTGEMM'] = {'f8':'cublasDgemm', 'f4':'cublasSgemm'}[dtype]
        str_dict['cublasTGEMMBatched'] = \
                {'f8':'cublasDgemmBatched', 'f4':'cublasSgemmBatched'}[dtype]
        str_dict.update(extra_str_dict)
        
        num_dict = {}
        num_dict['DEVID'] = self.devid
        num_dict['TPB'] = 256
        num_dict['TPBV'] = find_tpb_maxv(self.Nface*self.Nfp)
        num_dict['pNP'] = self.pNP
        num_dict['pNFF'] = self.pNFF
        num_dict.update(extra_num_dict)
        
        super(DGLM3DSingleCPU, self).save_to_header(filename_list, str_dict, num_dict, verbose)
        
    
    def build(self, filename_list, verbose=1):
        cmd = f"nvcc -O3 -std=c++11 -lcublas"
        
        super(DGLM3DSingleCPU, self).build(cmd, filename_list, verbose)



#==============================================================================
class DGLM3DMpiCPU(DGLM3DBase):
    def __init__(self, myrank, mpisize, dglm_dir, work_dir, N, Nvar, tmax, dglm_param):
        self.myrank  = myrank        
        self.mpisize = mpisize
        
        self.mypart = myrank + 1
        self.npart  = mpisize
        
        super().__init__(dglm_dir, work_dir, N, Nvar, tmax, dglm_param)
        
        
    def init_mesh(self, mesh_info, verbose=1):
        '''        
        mesh_info(dict):
            {'type':'gmsh', 'file':msh_file_fpath }
            {'type':'uniform', 'param':[nx, ny, nz, x1, x2, y1, y2, z1, z2, {'x':'pbc', 'y':'pbc', 'z':'pbc'}]}
        '''
        
        from mesh_3d import Mesh3D
        
        if mesh_info["type"] == "gmsh":            
            from gmsh_3d_partition import Gmsh3DPartition
            mesh_elem = Gmsh3DPartition(mesh_info["file"], self.mypart)  # *.msh file generated by Gmsh
            if verbose >= 1: print(f"Init Gmsh file: {mesh_info['file']}")
        
        elif mesh_info["type"] == "uniform":
            from uniform_3d_partition import Uniform3DPartition
            mesh_elem = Uniform3DPartition(self.mypart, self.npart, *mesh_info["param"])
            if verbose >= 1: print(f"Init uniform mesh: {mesh_info['param']}")
            
        self.mesh = Mesh3D(self.op_face, mesh_elem)
        self.Nelem = self.mesh.Nelem
        self.comm_size = self.mesh.part_size
        self.buf_size = self.mesh.sendbuf_face_idxs.size
        
    
    def make_work_dir(self):
        super().make_work_dir()
        
        self.datain_dir = os.path.join(self.work_dir, 'datain', f'rank{self.myrank}')
        self.dataout_dir = os.path.join(self.work_dir, 'dataout', f'rank{self.myrank}')

        os.makedirs(self.datain_dir, exist_ok=True)
        os.makedirs(self.dataout_dir, exist_ok=True)
            
            
    def save_to_binaries(self, extra_arr_dict={}, matrix_order='c', verbose=1):            
        arr_dict = {}
        arr_dict['dim'] = np.array([self.Nelem, self.myrank, self.comm_size, self.buf_size], 'i4')
        arr_dict['comm_face_idxs'] = self.mesh.comm_face_idxs        
        arr_dict['comm_nfp_idxs']  = self.mesh.comm_nfp_idxs
        arr_dict['sendbuf_face_idxs'] = self.mesh.sendbuf_face_idxs
        arr_dict['sendbuf_nfp_idxs']  = self.mesh.sendbuf_nfp_idxs
        extra_arr_dict.update(arr_dict)
        
        super().save_to_binaries(extra_arr_dict, matrix_order, verbose)
        
        
    def save_to_header(self, filename_list=[], extra_str_dict={}, extra_num_dict={}, verbose=1):
        dtype = self.param['dtype']
        str_dict = {}
        str_dict['MPIREAL'] = {'f8':'MPI_DOUBLE', 'f4':'MPI_FLOAT'}[dtype]
        str_dict['DATAIN']  = f'"{self.work_dir}/datain/rank__RANK__/"'
        str_dict['DATAOUT'] = f'"{self.work_dir}/dataout/rank__RANK__/"'
        str_dict.update(extra_str_dict)
        
        num_dict = {}
        num_dict['MPISIZE'] = self.mpisize
        num_dict.update(extra_num_dict)
        
        super().save_to_header(filename_list, str_dict, num_dict, verbose)
        
        
    def build(self, filename_list, use_sanitize=False, verbose=1):
        if use_sanitize:                
            cmd = f"mpic++ -O3 -std=c++11 -fopenmp -march=native -fsanitize=address,undefined"
        else:
            cmd = f"mpic++ -O3 -std=c++11 -fopenmp -march=native"     # opt3, vectorize, openmp
                
        super().build(cmd, filename_list, verbose)



#==============================================================================
class DGLM3DMpiGPU(DGLM3DMpiCPU):
    def __init__(self, myrank, mpisize, dglm_dir, work_dir, N, Nvar, tmax, dglm_param):
        super().__init__(myrank, mpisize, dglm_dir, work_dir, N, Nvar, tmax, dglm_param)
        
        # padded dimensions
        self.pNP  = ((self.Np - 1)//32 + 1)*32
        self.pNFF = ((self.Nface*self.Nfp - 1)//32 + 1)*32
        
        
    def save_to_header(self, filename_list=[], extra_str_dict={}, extra_num_dict={}, verbose=1):
        def find_tpb_maxv(NFF):
            # TPB (Threads Per Block) for calc_maxv() kernel
            m = 2
            min_diff = 1024
            opt_tpb  = -1

            while True:
                tpb = NFF*m
                if (tpb > 1024): break

                for ref_tpb in [256, 512, 1024]:
                    diff = abs(tpb - ref_tpb)
                    if diff < min_diff:
                        min_diff = diff
                        opt_tpb = tpb
                m += 2
            return opt_tpb        
        
        fmax = {'f8':'fmax', 'f4':'fmaxf'}[self.param['dtype']]
        banksize = {'f8':'cudaSharedMemBankSizeEightByte',
                    'f4':'cudaSharedMemBankSizeFourByte'}[self.param['dtype']]
        cu_amax = {'f8':'cublasIdamax', 'f4':'cublasIsamax'}[self.param['dtype']]
        cu_gemm = {'f8':'cublasDgemm', 'f4':'cublasSgemm'}[self.param['dtype']]
        cu_gemm_batch = {'f8':'cublasDgemmBatched', 'f4':'cublasSgemmBatched'}[self.param['dtype']]

        dtype = self.param['dtype']
        str_dict = {}
        str_dict['FMAX'] = {'f8':'fmax', 'f4':'fmaxf'}[dtype]
        str_dict['cudaSharedMemBankSizeTByte'] = \
                {'f8':'cudaSharedMemBankSizeEightByte',
                 'f4':'cudaSharedMemBankSizeFourByte'}[dtype]
        str_dict['cublasITAMAX'] = {'f8':'cublasIdamax', 'f4':'cublasIsamax'}[dtype]
        str_dict['cublasTGEMM'] = {'f8':'cublasDgemm', 'f4':'cublasSgemm'}[dtype]
        str_dict['cublasTGEMMBatched'] = \
                {'f8':'cublasDgemmBatched', 'f4':'cublasSgemmBatched'}[dtype]
        str_dict['NCCLREAL'] = {'f8':'ncclDouble', 'f4':'ncclFloat'}[dtype]
        str_dict.update(extra_str_dict)
        
        num_dict = {}        
        num_dict['TPB'] = 256
        num_dict['TPBV'] = find_tpb_maxv(self.Nface*self.Nfp)
        num_dict['pNP'] = self.pNP
        num_dict['pNFF'] = self.pNFF
        num_dict.update(extra_num_dict)
        
        super().save_to_header(filename_list, str_dict, num_dict, verbose)
    
    
    def build(self, filename_list, verbose=1):
        cmd = "mpic++ -showme:incdirs"
        result = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        inc_dirs = "".join([f"-I{d} " for d in result.stdout.split()])

        cmd = "mpic++ -showme:libdirs"
        result = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        lib_dirs = "".join([f"-L{d} " for d in result.stdout.split()])
        
        compile_cmd = f"nvcc -O3 -std=c++11 {inc_dirs} {lib_dirs} -lcublas -lnccl -lmpi"
        
        super(DGLM3DMpiCPU, self).build(compile_cmd, filename_list, verbose)
